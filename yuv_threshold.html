<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>YUV Threshold Visualizer</title>
  <style>
    input[type=range] {
        width: 20em;
    }
    input[type=number] {
        width: 5em;
    }
    td {
        width: 25em;
    }
    #min_color, #max_color {
        height: 1em;
        width: 20em;
    }
    #threshold_overlay {
        position: relative;
        left: -160px;
    }
  </style>
</head>

<body>
  <header>
    <h1>YUV Threshold Visualizer</h1>
  </header>

  <main>
    <canvas id="image" width="160" height="120"></canvas>
    <canvas id="threshold" width="160" height="120"></canvas><canvas id="threshold_overlay" width="160" height="120"></canvas>
    <table>
        <tr>
            <td>RGB: <span id="live_rgb">0, 0, 0</span>&nbsp;<span id="live_rgb_color">&nbsp;&nbsp;&nbsp;&nbsp;</span></td>
            <td>YUV: <span id="live_yuv">0, 0, 0</span>&nbsp;<span id="live_yuv_color">&nbsp;&nbsp;&nbsp;&nbsp;</span></td>
        </tr>
        <tr>
            <td>RGB (selected): <span id="selected_rgb">Click on image to display</span>&nbsp;<span id="selected_rgb_color">&nbsp;&nbsp;&nbsp;&nbsp;</span></td>
            <td>YUV (selected): <span id="selected_yuv">Click on image to display</span>&nbsp;<span id="selected_yuv_color">&nbsp;&nbsp;&nbsp;&nbsp;</span></td>
        </tr>
    </table>

    <br>
    <p>You must set the width and height correctly before loading the YUV file.</p>
    Width:<input id="width" type="number" value="160" step="1">
    Height:<input id="height" type="number" value="120" step="1">
    <input id="file" type="file">
    <br><br>

    <select id="blur">
        <option value="noblur">No Blurring</option>
        <option value="gaussian_3x3">3x3 Gaussian Blur</option>
    </select>

    <table>
        <tr>
            <td>Y Min:<input id="y_min" type="range" min="0" max="255" value="0" step="1"><span id="y_min_val">0</span></td>
            <td>Y Max:<input id="y_max" type="range" min="0" max="255" value="255" step="1"><span id="y_max_val">255</span></td>
        </tr>
        <tr>
            <td>U Min:<input id="u_min" type="range" min="0" max="255" value="0" step="1"><span id="u_min_val">0</span></td>
            <td>U Max:<input id="u_max" type="range" min="0" max="255" value="255" step="1"><span id="u_max_val">255</span></td>
        </tr>
        <tr>
            <td>V Min:<input id="v_min" type="range" min="0" max="255" value="0" step="1"><span id="v_min_val">0</span></td>
            <td>V Max:<input id="v_max" type="range" min="0" max="255" value="255" step="1"><span id="v_max_val">255</span></td>
        </tr>
        <tr>
            <td><canvas id="yuv_min_plane" width="256" height="256"></canvas></td>
            <td><canvas id="yuv_max_plane" width="256" height="256"></canvas></td>
        </tr>
    </table>
  </main>

  <script>
    let raw;
    let yuv;
    let width;
    let height;

    function copyData(buf) {
        let outBuf = [];
        for (let i=0; i<buf.length; i++) {
            outBuf.push(buf[i]);
        }
        return outBuf;
    }

    function gaussian_3x3_yuv(buf, w, h) {
        let blurred = [];
        for (let i=0; i<w*h*2; i++) {
            blurred.push(buf[i]);
        }

        for (let y=0; y<height; y++) {
            let row = y * width;
            let row_m1 = y - 1;
            let row_p1 = y + 1;
            if (row_m1 < 0) {
                row_m1 *= -1;
            } else if (row_p1 > height - 1) {
                row_p1 = 2 * height - row_p1 - 2;
            }
            row_m1 *= width;
            row_p1 *= width;

            for (x=0; x<width; x++) {
                let pos = row + x;
                let x_m1 = x-1;
                let x_p1 = x+1;
                if (x_m1 < 0) {
                    x_m1 *= -1
                } else if (x_p1 > width - 1) {
                    x_p1 = 2 * width - x_p1 - 2;
                }
                let pixel = 4 * buf[2 * pos];
                pixel += 2 * (buf[2 * (row + x_m1)] + buf[2 * (row + x_p1)] + buf[2 * (row_m1 + x)] + buf[2 * (row_p1 + x)]);
                pixel += buf[2 * (row_m1 + x_m1)] + buf[2 * (row_m1 + x_p1)] + buf[2 * (row_p1 + x_m1)] + buf[2 * (row_p1 + x_p1)];
                blurred[2 * pos] = Math.floor(pixel / 16);
            }
        }

        let halfWidth = width / 2;
        for (let y=0; y<height; y++) {
            let row = y * halfWidth * 4;
            let row_m1 = y - 1;
            let row_p1 = y + 1;
            if (row_m1 < 0) {
                row_m1 *= -1;
            } else if (row_p1 > height - 1) {
                row_p1 = 2 * height - row_p1 - 2;
            }
            row_m1 *= halfWidth * 4;
            row_p1 *= halfWidth * 4;

            for (x=0; x<halfWidth; x++) {
                x4 = x * 4
                let pos = row + x4;
                let x_m1 = x-1;
                let x_p1 = x+1;
                if (x_m1 < 0) {
                    x_m1 *= -1
                } else if (x_p1 > halfWidth  - 1) {
                    x_p1 = 2 * halfWidth - x_p1 - 2;
                }
                x_m1 *= 4;
                x_p1 *= 4;

                let u = 4 * buf[pos + 1];
                u += 2 * (buf[row + x_m1 + 1] + buf[row + x_p1 + 1] + buf[row_m1 + x4 + 1] + buf[row_p1 + x4 + 1]);
                u += buf[row_m1 + x_m1 + 1] + buf[row_m1 + x_p1 + 1] + buf[row_p1 + x_m1 + 1] + buf[row_p1 + x_p1 + 1];
                blurred[pos + 1] = Math.floor(u / 16);

                let v = 4 * buf[pos + 3];
                v += 2 * (buf[row + x_m1 + 3] + buf[row + x_p1 + 3] + buf[row_m1 + x4 + 3] + buf[row_p1 + x4 + 3]);
                v += buf[row_m1 + x_m1 + 3] + buf[row_m1 + x_p1 + 3] + buf[row_p1 + x_m1 + 3] + buf[row_p1 + x_p1 + 3];
                blurred[pos + 3] = Math.floor(v / 16);
            }
        }

        return blurred
    }

    function drawYUV() {
        let imageCanvas = document.getElementById('image');
        imageCanvas.width = width;
        imageCanvas.height = height;

        let ctx = imageCanvas.getContext('2d');

        const imageData = ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height);
        const data = imageData.data;
        for (let y=0; y<height; y++) {
            for (let x=0; x<width; x+=2) {
                let pos = (y * width + x);
                let yuv_pos = pos * 2 ;
                let canvas_pos = pos * 4;

                let y1 = yuv[yuv_pos];
                let u = yuv[yuv_pos + 1];
                let y2 = yuv[yuv_pos + 2];
                let v = yuv[yuv_pos + 3];

                let rgb1 = yuv2rgb_jpeg(y1, u, v);
                let rgb2 = yuv2rgb_jpeg(y2, u, v);

                data[canvas_pos] = rgb1[0];
                data[canvas_pos + 1] = rgb1[1];
                data[canvas_pos + 2] = rgb1[2];
                data[canvas_pos + 3] = 255;
                data[canvas_pos + 4] = rgb2[0];
                data[canvas_pos + 5] = rgb2[1];
                data[canvas_pos + 6] = rgb2[2];
                data[canvas_pos + 7] = 255;
            }
        }
        ctx.putImageData(imageData, 0, 0);
    }

    function drawThreshold() {
        let yMin = parseInt(document.getElementById('y_min').value);
        let yMax = parseInt(document.getElementById('y_max').value);
        let uMin = parseInt(document.getElementById('u_min').value);
        let uMax = parseInt(document.getElementById('u_max').value);
        let vMin = parseInt(document.getElementById('v_min').value);
        let vMax = parseInt(document.getElementById('v_max').value);
        let thresholdCanvas = document.getElementById('threshold');
        let thresholdOverlayCanvas = document.getElementById('threshold_overlay');

        thresholdCanvas.width = width;
        thresholdCanvas.height = height;
        thresholdOverlayCanvas.width = width;
        thresholdOverlayCanvas.height = height;

        let ctx = thresholdCanvas.getContext('2d');

        if (! yuv) {
            return
        }

        const imageData = ctx.getImageData(0, 0, thresholdCanvas.width, thresholdCanvas.height);
        const data = imageData.data;
        for (let y=0; y<height; y++) {
            for (let x=0; x<width; x+=2) {
                let pos = (y * width + x);
                let yuv_pos = pos * 2 ;
                let canvas_pos = pos * 4;

                let y1 = yuv[yuv_pos];
                let u = yuv[yuv_pos + 1];
                let y2 = yuv[yuv_pos + 2];
                let v = yuv[yuv_pos + 3];

                let value = 0;
                if (yMin <= y1 && y1 <= yMax && uMin <= u && u <= uMax && vMin <= v && v <= vMax) {
                    value = 255;
                }
                data[canvas_pos] = value;
                data[canvas_pos + 1] = value;
                data[canvas_pos + 2] = value;
                data[canvas_pos + 3] = 255;

                value = 0;
                if (yMin <= y2 && y2 <= yMax && uMin <= u && u <= uMax && vMin <= v && v <= vMax) {
                    value = 255;
                }
                data[canvas_pos + 4] = value;
                data[canvas_pos + 5] = value;
                data[canvas_pos + 6] = value;
                data[canvas_pos + 7] = 255;
            }
        }
        ctx.putImageData(imageData, 0, 0);
    }

    function yuv2rgb_jpeg(y, u, v) {
        y = y;
        u = u - 128;
        v = v - 128;

        r = y + 1.402 * v;
        g = y - 0.344136 * u - 0.714136 * v;
        b = y + 1.772 * u;

        r = Math.round(Math.max(Math.min(r, 255), 0));
        g = Math.round(Math.max(Math.min(g, 255), 0));
        b = Math.round(Math.max(Math.min(b, 255), 0));

        return [r, g, b];
    }

    function loadFile(e) {
        let files = e.target.files;

        if (files.length == 0) {
            return;
        }

        let reader = new FileReader();
        reader.onload = function (e) {
            width = parseInt(document.getElementById('width').value);
            height = parseInt(document.getElementById('height').value);

            raw = new Uint8Array(e.target.result);

            process();
        };
        reader.readAsArrayBuffer(files[0]);
    }

    function process() {
        let blurSelect = document.getElementById('blur');

        if (blurSelect.value == 'gaussian_3x3') {
            yuv = gaussian_3x3_yuv(raw, width, height);
        } else {
            yuv = copyData(raw);
        }

        drawYUV();
        drawThreshold();
    }

    function drawYUVPlane(id, y, uMin, uMax, vMin, vMax) {
        let imageCanvas = document.getElementById(id);
        let ctx = imageCanvas.getContext('2d');

        const imageData = ctx.getImageData(0, 0, imageCanvas.width, imageCanvas.height);
        const data = imageData.data;
        for (let v=0; v<256; v++) {
            for (let u=0; u<256; u++) {
                let pos = ((256 - v) * 256 + u) * 4;

                let rgb = yuv2rgb_jpeg(y, u, v);
                data[pos] = rgb[0];
                data[pos + 1] = rgb[1];
                data[pos + 2] = rgb[2];
                data[pos + 3] = 255;
            }
        }
        ctx.putImageData(imageData, 0, 0);

        // Draw min, max lines
        ctx.beginPath();
        ctx.moveTo(uMin, 0);
        ctx.lineTo(uMin, 255);
        ctx.moveTo(uMax, 0);
        ctx.lineTo(uMax, 255);
        ctx.moveTo(0, 255-vMin);
        ctx.lineTo(255, 255-vMin);
        ctx.moveTo(0, 255-vMax);
        ctx.lineTo(255, 255-vMax);
        ctx.strokeStyle = '#000000';
        ctx.stroke();
    }

    function sliderChange() {
        let yMin = parseInt(document.getElementById('y_min').value);
        let yMax = parseInt(document.getElementById('y_max').value);
        let uMin = parseInt(document.getElementById('u_min').value);
        let uMax = parseInt(document.getElementById('u_max').value);
        let vMin = parseInt(document.getElementById('v_min').value);
        let vMax = parseInt(document.getElementById('v_max').value);

        document.getElementById('y_min_val').innerText = yMin;
        document.getElementById('y_max_val').innerText = yMax;
        document.getElementById('u_min_val').innerText = uMin;
        document.getElementById('u_max_val').innerText = uMax;
        document.getElementById('v_min_val').innerText = vMin;
        document.getElementById('v_max_val').innerText = vMax;

        drawYUVPlane('yuv_min_plane', yMin, uMin, uMax, vMin, vMax);
        drawYUVPlane('yuv_max_plane', yMax, uMin, uMax, vMin, vMax);

        drawThreshold();
    }

    function getColor(event) {
        let canvas = document.getElementById('image');
        let width = parseInt(document.getElementById('width').value);

        let ctx = canvas.getContext("2d");
        const bounding = canvas.getBoundingClientRect();
        const x = Math.floor(event.clientX - bounding.left);
        const y = Math.floor(event.clientY - bounding.top);

        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;

        let colors = [[], []]
        let pos = (y * width + x) * 4;
        colors[0] = [data[pos+0], data[pos+1], data[pos+2]];
        pos = (y * width + x) * 2;

        if (x % 2) {
            colors[1] = [yuv[pos], yuv[pos-1], yuv[pos+1]];
        } else {
            colors[1] = [yuv[pos], yuv[pos+1], yuv[pos+3]];
        }

        return colors;
    }

    function pickColor(event) {
        let selected_rgb = document.getElementById('selected_rgb');
        let selected_yuv = document.getElementById('selected_yuv');
        let selected_rgb_color = document.getElementById('selected_rgb_color');
        let selected_yuv_color = document.getElementById('selected_yuv_color');

        if (! yuv) {
            return;
        }

        colors = getColor(event);

        selected_rgb.innerText = colors[0][0] + ', ' + colors[0][1] + ', ' + colors[0][2];
        selected_yuv.innerText = colors[1][0] + ', ' + colors[1][1] + ', ' + colors[1][2];
        selected_rgb_color.style.backgroundColor = 'rgb(' + colors[0][0] + ', ' + colors[0][1] + ', ' + colors[0][2] + ')';
        selected_yuv_color.style.backgroundColor = 'rgb(' + colors[0][0] + ', ' + colors[0][1] + ', ' + colors[0][2] + ')';
    }

    function liveColor(event) {
        let live_rgb = document.getElementById('live_rgb');
        let live_yuv = document.getElementById('live_yuv');
        let live_rgb_color = document.getElementById('live_rgb_color');
        let live_yuv_color = document.getElementById('live_yuv_color');

        if (! yuv) {
            return;
        }

        colors = getColor(event);

        live_rgb.innerText = colors[0][0] + ', ' + colors[0][1] + ', ' + colors[0][2];
        live_yuv.innerText = colors[1][0] + ', ' + colors[1][1] + ', ' + colors[1][2];
        live_rgb_color.style.backgroundColor = 'rgb(' + colors[0][0] + ', ' + colors[0][1] + ', ' + colors[0][2] + ')';
        live_yuv_color.style.backgroundColor = 'rgb(' + colors[0][0] + ', ' + colors[0][1] + ', ' + colors[0][2] + ')';
    }

    function drawThresholdTarget(event) {
        let canvas = document.getElementById('image');
        let overlay = document.getElementById('threshold_overlay');

        let ctx = overlay.getContext("2d");
        const bounding = canvas.getBoundingClientRect();
        const x = Math.floor(event.clientX - bounding.left);
        const y = Math.floor(event.clientY - bounding.top);

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.strokeStyle = '#8888';
        ctx.stroke();
    }

    function mouseMove(event) {
        drawThresholdTarget(event);
        liveColor(event);
    }

    document.getElementById('file').onchange = loadFile;
    document.getElementById('y_min').oninput = sliderChange;
    document.getElementById('y_max').oninput = sliderChange;
    document.getElementById('u_min').oninput = sliderChange;
    document.getElementById('u_max').oninput = sliderChange;
    document.getElementById('v_min').oninput = sliderChange;
    document.getElementById('v_max').oninput = sliderChange;
    document.getElementById('image').onclick = pickColor;
    document.getElementById('image').onmousemove = mouseMove;
    document.getElementById('blur').onchange = process;

    drawYUVPlane('yuv_min_plane', 0, 0, 255, 0, 255);
    drawYUVPlane('yuv_max_plane', 0, 0, 255, 0, 255);
  </script>
</body>
</html>
